-------------------------------------------------------
Domain layer

Сущность:
	Сущности должны всегда находиться в валидном состоянии. Не каких репо, бд, только чситые сушности их аттрибуты и методы, которые изменяют его состояние
	Сущности отвечают только за свою консистентность.
	Правила, которые всегда должны выполняться для сущности, называют invariants (неизменяемые условия).
	Все такие правила должны быть внутри сущности, а не снаружи.
	Если нарушать это правило, доменные сущности теряют чистоту, становятся трудно тестируемыми и жестко привязанными к внешним технологиям.
	Методы агрегата — единственная точка изменения состояния (нет прямых присвоений статусов извне).
	Даже внешние части приложения не могут нарушить invariants, потому что доступ только через методы.


Про encapsulation:
	Все, что может изменяться только через бизнес-логику, должно быть закрытым (private или protected).
	Пример: статус задачи, роль пользователя, хэш пароля.
	Просто данные без бизнес-логики могут быть публичными.
	Пример: first_name, last_name, если их можно менять напрямую без нарушений правил.
	
	У меня такое правила. Делаю приватнимы, если будет необходимость сделать протект то делаю протект

Про геттеры и сеттеры:
	Геттеры (@property):
	Используются, когда нужно публично читать приватное поле.
	Можно возвращать преобразованное или безопасное значение.
	
	Сеттеры (@property.setter):
	Используются крайне осторожно.
	В DDD сеттеры почти всегда заменяются методами бизнес-логики, чтобы не нарушать инварианты.

В общем геттеры сеттеры почти не нужно



---------------------------------------------------------
Application layer

Application layer не содержит бизнес-правил.
Он только управляет «сценарием», а бизнес-правила уже внутри Domain layer.

Error handling & validation

Проверяет данные на входе (например, что email не пустой).

Перехватывает ошибки из домена (InvalidDeadlineError) и переводит их в «понятные» ошибки для клиента.

Если операция затрагивает несколько сущностей (например, создание заказа и списание денег), то Application layer управляет транзакцией.
При ошибке делает rollback.

Переводит DTO → Domain
Переводит Domain → Response

⚖️ Важный момент
Application layer не содержит бизнес-правил.
Он только управляет «сценарием», а бизнес-правила уже внутри Domain layer.


⚖️ Важное правило Clean Architecture
В Application layer мы только ожидаемые доменные ошибки перехватываем и преобразуем.
Всякие except Exception: здесь не пишем → глобальная обработка ошибок должна быть во внешних слоях (например, middleware веб-фреймворка).
В место генерирование новых исключений используем Result type pattern	



Главная мысль

Application layer (Слой приложений) — это связующее звено между интерфейсами (например, HTTP, CLI, gRPC) и доменной моделью.

Он:
1) Принимает входные данные (обычно через DTO).
2) Проверяет и преобразует их в формат, удобный для домена.
3) Запускает use case interactor (конкретный сценарий работы).
4) Оркестрирует работу доменных сущностей + обращается к внешним сервисам через порты.
5) Возвращает результат (Result.success или Result.failure) обратно в интерфейсный слой.

В чистой архитектуре порты (интерфейсы, контракты) обычно живут в Application layer.


DTO (Data Transfer Object) — это объект для передачи данных между слоями или системами без добавления какой-либо бизнес-логики. Его основная цель — безопасно и удобно переносить данные.

Для Use case будем использовать Request Response DTO
Request и Response модели — это DTO (Data Transfer Objects), которые:
1)Ограждают Domain Layer от внешних форматов
  Например, строковые ID из HTTP-запроса преобразуются в UUID для домена.
3)Ограждают внешние интерфейсы от внутренней реализации
  Внешний клиент не видит внутренние структуры объектов домена.
5)Выполняют валидацию данных
  Catch malformed data до того, как она попадёт в Use Case.
  
  
Request DTO

Внешний слой (например, API-контроллер) получает данные от пользователя.

Эти данные упаковываются в Request DTO, где:
 Валидируются (например, обязательные поля, длина текста).
 Преобразуются в типы, которые понятны домену (строки → UUID, timestamp → datetime).
 Use Case получает только валидные, корректно преобразованные данные, без необходимости заботиться о формате входа.
 
 
Response DTO → Внешний слой

Внешний слой (API, CLI, MQ) получает Response DTO и уже сериализует его в JSON, XML, консольный вывод или сообщение.
Вся бизнес-логика остаётся скрытой, слой приложения полностью контролирует границу между доменом и внешним миром.

-------------------------------------
Interface Adapters

Переводят данные из внешнего мира понятним для application layer

Главные компоненты
Контроллери - получают данные из внешнего мира, вызивает use case и возвращают данные для внешнего мира
Презентатор - Преоброзует сущность как данные удобно для клиентов
View - отображает данные

Поток
1) Контроллер получает некоторые данные из внешнего мира 
2) В контроллере вызивается UseCase
3) UseCase возвращает сущность через Result type
4) В контроллере  Presenter преврощает сущность на Viewmodel
5) Контроллер возвращает viewmodel через OperationResult Pattern

Контроллер возвращает данные через OperationResult pattern
Если есть несколько API для других сервисов, и один из них визвет исключение так будет сложно понять какое из них упало, а через этот паттерн легко
